# Simplify Form Handling in React 19: Introducing `useActionState` Hook

React 19's new `useActionState` hook simplifies handling asynchronous operations in React, especially when dealing with forms. Let's delve into a practical example to see it in action.

Here we have a simple read-only form ready for submission:

```typescript
"use client"

export const FormAction = () => {
  return (
    <div>
      <form>
        <input type="text" name="name" value="Hello from actions" readOnly />
        <button type="submit">
          Submit
        </button>
      </form>
      <footer>
        <p>Awaiting action üöÄ</p>
      </footer>
    </div>
  );
};
```

The `useActionState` hook takes a minimum of two arguments: (1) an asynchronous action, that in turns takes its own arguments of `previousState` and a generic payload, and (2) an initial state; The hook provides (a) the awaited state, (b) a dispatcher and (c) an `isPending` boolean.

```typescript
// canary.d.ts
export function useActionState<State, Payload>(
    action: (state: Awaited<State>, payload: Payload) => State | Promise<State>,
    initialState: Awaited<State>,
): [state: Awaited<State>, dispatch: (payload: Payload) => void, isPending: boolean];
```

So let's define our state's type definition along with our initial state vaue to begin shaping our component.

```typescript
"use client";

import { useActionState } from "react";

type State =
  | { data: string; status: "SUCCESS" }
  | { status: "ERROR" | "INIT" };
const initState: State = { status: "INIT" };

export const FormAction = () => {
  const [action, submitAction, isPending] = useActionState(
    async (prevState: State, formData: FormData) =>
      runAction(prevState, String(formData.get("name"))),
    initState
  );

  return (
    <div>
      <form action={submitAction}>
        <input type="text" name="name" value="Hello from actions" readOnly />
        <button type="submit" disabled={isPending}>
          Submit
        </button>
      </form>
      <footer>
        {action.status === "INIT" && <p>Awaiting action üöÄ</p>}
        {action.status === "SUCCESS" && <p>Success, all good ‚úÖ</p>}
        {action.status === "ERROR" && <p>Error, please resubmit action ‚ùå</p>}
      </footer>
    </div>
  );
};
```

Notice how `submitAction`, a function generated by `useActionState`, is used directly in the form's `action` attribute. The submission button is disabled based on the `isPending` boolean which allows us to manage the pending state effectively. As for the form's feedback mechanism, it responds dynamically to changes in action's state.

The `runAction` function here is a mock, simulating an API call which randomly succeds or fails returning a new state, updating the form's status to either `SUCCESS` or `ERROR`.

```typescript
async function runAction(prevState: State, data: string) {
  return new Promise<State>((r) => {
    console.log(prevState);
    setTimeout(
      () =>
        Math.random() < 0.5
          ? r({ data, status: "SUCCESS" })
          : r({ status: "ERROR" }),

      1500
    );
  });
}
```

Why not leverage `useActionState` in your next React project? What do you think? Does it make it easier or not to to manage state, side effects and boilerplate in form operations?

Check out the code snippets and demo in [webscopeio/examples/tree/main/use-action-state](https://github.com/webscopeio/examples/tree/main/use-action-state)
